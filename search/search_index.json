{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Splitter","text":""},{"location":"#overview","title":"Overview","text":"<p>The Splitter application aims to convert documents into markdown format, and split them into chunks using various splitting strategies. The architecture consists of three main pieces: the <code>ReadManager</code>, the <code>SplitManager</code> and the <code>ChunkManager</code>. Observe the following diagram:</p> <p></p>"},{"location":"#how-to-launch-the-application","title":"How to launch the application","text":"<p>The application is exposed via:</p> <ul> <li>REST API</li> <li>CLI</li> </ul>"},{"location":"#pre-requisites","title":"Pre-requisites","text":"<p>The following tools and packages are needed to execute the application:</p> <ul> <li>Python with <code>make</code>. <code>$PYTHONPATH</code> may be set in the <code>.env</code> file.</li> <li>Docker.</li> </ul> <p>To install all the dependencies, you can use <code>make install</code>.</p> <pre><code>make install\n</code></pre> <p>This application uses <code>uv</code> as dependency management tool, if not installed, use the following command:</p> <pre><code>make install-uv\n</code></pre>"},{"location":"#api","title":"API","text":"<p>The API is accessed through a FastAPI application. This application can be launched executing:</p> <pre><code>make serve\n</code></pre>"},{"location":"#api-definition","title":"API Definition","text":""},{"location":"#input","title":"Input","text":"<p>Object: <code>class &lt;ChunkRequest&gt;</code></p> <pre><code>document_name: Optional[str] = None\ndocument_path: str\ndocument_id: Optional[str] = None\nsplit_method: str\nsplit_params: Optional[Dict[str, Any]] = None\nmetadata: Optional[List[str]] = []\n</code></pre>"},{"location":"#output","title":"Output","text":"<p>Object: <code>class &lt;ChunkResponse&gt;</code></p> <pre><code>chunks: List[str]\nchunk_id: List[str]\nchunk_path: str\ndocument_id: str\ndocument_name: Optional[str] = None\nsplit_method: str\nsplit_params: Optional[Dict[str, Any]] = None\nmetadata: Optional[List[str]] = []\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>The application is accessible through Command Line Interface (CLI) using the following command:</p> <pre><code>make run\n</code></pre>"},{"location":"#docker","title":"Docker","text":"<p>The API-interface can be launched using Docker with the following Make commands:</p> <p>Build the image:</p> <pre><code>make docker-api-build # build the image\n</code></pre> <p>Run the image:</p> <pre><code>make docker-api-run # run the image\n</code></pre> <p>Application will be accessible through the browser at the host <code>0.0.0.0:8080/docs</code>. </p> <p>These values are configurable through the following environment variables:</p> <pre><code>PORT=8080\nHOST=0.0.0.0\nLOG_LEVEL=info\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>File handling, splitting methods and application settings can be modified using a configuration file. This file is provided in <code>src/config.yaml</code> file. Otherwise, parameters can be passed as API parameters. The config file has the following structure by default:</p> <pre><code># 1. File I/O Configuration\nfile_io:\n  input_path: \"data/input\"     # Where the application reads files from\n  output_path: \"data/output\"   # Where the application saves the results\n\n# 2. Logging Configuration\nlogging:\n  enabled: true                # Set to false to disable logging\n  level: \"INFO\"                # Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL\n  format: \"%(asctime)s - %(levelname)s - %(message)s\"\n  handlers:\n    - type: \"stream\"\n    - type: \"file\"\n      filename: \"logs/app.log\"\n      mode: \"a\"\n\n# 3. Splitting Methods Configuration\nsplitter:\n  method: \"recursive\"\n\n  methods:\n    word:\n      num_words: 100  # Number of words in each chunk\n\n    sentence:\n      num_sentences: 5  # Number of sentences in each chunk\n\n    paragraph:\n      num_paragraphs: 3  # Number of paragraphs in each chunk\n\n    semantic:\n      language_model: \"bert-base-uncased\"  # For semantic similarity\n      overlap: 0.2                         # Overlap ratio between chunks\n\n    fixed:\n      size: 100  # Number of characters per chunk\n\n    paged:\n      num_pages: 1  # Number of pages in each chunk\n      overlap: 0.1  # Overlap (in pages) between chunks\n\n    recursive:\n      size: 10000     # Characters per chunk\n      overlap: 1000   # Overlapping characters\n\n    row-column:\n      num_columns: 2\n      column_names: [\"Column1\", \"Column2\"]\n      num_rows: 5\n      row_names: [\"Row1\", \"Row2\"]\n\n    schema-based:\n      num_registers: 50  # Number of registers (or rows) per chunk\n      overlap: 5         # Overlapping registers\n\n    auto:\n      fallback_method: \"paragraph\"\n      chunk_size: 500\n      overlap: 100\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#1-read-manager","title":"1. Read Manager","text":"<ul> <li>Responsible for reading input documents.</li> <li>Supports local file formats: <code>txt</code>, <code>md</code>, <code>docx</code>, <code>xls</code>, <code>xlsx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code>, <code>json</code>, <code>yaml</code>.</li> <li>If required, OCR can be applied to extract text from scanned documents.</li> </ul>"},{"location":"#2-split-manager","title":"2. Split Manager","text":"<ul> <li>Splits text into meaningful chunks based on different strategies.</li> <li>Includes the following methods:</li> </ul> Splitter Name Description Parameters Compatible Formats Word Splitter Splits text into words. Input data, number of words in each chunk. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Sentence Splitter Splits text into sentences. Input data, number of sentences in each chunk. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Paragraph Splitter Splits text into paragraphs. Input data, number of paragraphs in each chunk. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Semantic Splitter Splits text based on semantic similarity, using a language model. Input data, language model, overlap. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Fixed Splitter Splits text into a fixed number of words or characters. Input data, number of characters in each chunk. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Paged Splitter Splits text into pages. Input data, number of pages in each chunk, overlap. <code>docx</code>, <code>pdf</code>, <code>xls</code>, <code>xlsx</code>, <code>ppt</code>, <code>pptx</code> Recursive Splitter Splits based on a specified chunk size with overlap. Input data, number of characters in each chunk, overlap parameter. <code>txt</code>, <code>markdown</code>, <code>docx</code>, <code>pdf</code>, <code>ppt</code>, <code>pptx</code> Row-Column Splitter Splits table content by rows or columns. Input data, number of columns, column names, number of rows, row names. <code>xlsx</code>, <code>xls</code>, <code>json</code>, <code>yaml</code> Schema-based Splitter Splits a hierarchical schema while preserving headers. Input data, number of registers, overlap. <code>json</code>, <code>yaml</code>, <code>xml</code>, <code>xls</code>, <code>xlsx</code>, <code>ppt</code>, <code>pptx</code> Auto Splitter Combines multiple splitting methods based on document content. Input data, number of characters in each chunk, overlap. All formats"},{"location":"#3-chunk-manager","title":"3. Chunk Manager","text":"<ul> <li>Saves the generated chunks from Chunk Manager.</li> <li>Features:</li> <li>Aggregator: Groups related chunks.</li> <li>Markdown conversion: Converts text into Markdown format.</li> <li>Error handling: Ensures smooth chunking.</li> </ul>"},{"location":"#project-scenario","title":"Project scenario","text":"<p>This application compose a piece of an ambicious project named \"MultiRAG\". This system aims to be a super modullarizable and open-source RAG system which is fully customizable piece by piece. Observe the following architecture diagram:</p> <p>MultiRAG architecture</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>.\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 Dockerfile.api\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 input\n\u2502   \u2502   \u2514\u2500\u2500 andres_herencia_TFM_TECI.pdf\n\u2502   \u251c\u2500\u2500 output\n\u2502   \u2514\u2500\u2500 test\n\u2502       \u251c\u2500\u2500 input\n\u2502       \u2502   \u251c\u2500\u2500 test_1.docx\n\u2502       \u2502   \u251c\u2500\u2500 test_1.md\n\u2502       \u2502   \u251c\u2500\u2500 test_1.pdf\n\u2502       \u2502   \u2514\u2500\u2500 test_1.txt\n\u2502       \u2514\u2500\u2500 output\n\u251c\u2500\u2500 docker-compose.yaml\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 assets\n\u2502   \u2502   \u251c\u2500\u2500 MultiRAG.drawio.svg\n\u2502   \u2502   \u251c\u2500\u2500 splitter.drawio.svg\n\u2502   \u2502   \u2514\u2500\u2500 splitter.drawio_v0.1.0.drawio.svg\n\u2502   \u251c\u2500\u2500 chunker\n\u2502   \u2502   \u2514\u2500\u2500 docs.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 reader\n\u2502   \u2502   \u2514\u2500\u2500 docs.md\n\u2502   \u2514\u2500\u2500 splitter\n\u2502       \u2514\u2500\u2500 docs.md\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 conftest.py\n\u2502   \u2514\u2500\u2500 validate_commit_msg.py\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2514\u2500\u2500 __init__.cpython-312.pyc\n\u2502   \u251c\u2500\u2500 application\n\u2502   \u2502   \u251c\u2500\u2500 api\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 app.cpython-312.pyc\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 models.cpython-312.pyc\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 app.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 routers\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2502       \u2502   \u2514\u2500\u2500 split.cpython-312.pyc\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 split.py\n\u2502   \u2502   \u2514\u2500\u2500 cli.py\n\u2502   \u251c\u2500\u2500 chunker\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.cpython-312.pyc\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 chunk_manager.cpython-312.pyc\n\u2502   \u2502   \u2514\u2500\u2500 chunk_manager.py\n\u2502   \u251c\u2500\u2500 config.yaml\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 reader\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.cpython-312.pyc\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 read_manager.cpython-312.pyc\n\u2502   \u2502   \u2514\u2500\u2500 read_manager.py\n\u2502   \u251c\u2500\u2500 splitter\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 __pycache__\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.cpython-312.pyc\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 base_splitter.cpython-312.pyc\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 split_manager.cpython-312.pyc\n\u2502   \u2502   \u251c\u2500\u2500 base_splitter.py\n\u2502   \u2502   \u251c\u2500\u2500 split_manager.py\n\u2502   \u2502   \u2514\u2500\u2500 splitters\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u251c\u2500\u2500 __pycache__\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 __init__.cpython-312.pyc\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 fixed_splitter.cpython-312.pyc\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 paragraph_splitter.cpython-312.pyc\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 recursive_splitter.cpython-312.pyc\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 sentence_splitter.cpython-312.pyc\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 word_splitter.cpython-312.pyc\n\u2502   \u2502       \u251c\u2500\u2500 auto_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 fixed_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 paged_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 paragraph_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 recursive_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 row_column_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 schema_based_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 semantic_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 sentence_splitter.py\n\u2502   \u2502       \u2514\u2500\u2500 word_splitter.py\n\u2502   \u2514\u2500\u2500 utils\n\u2502       \u251c\u2500\u2500 __pycache__\n\u2502       \u2502   \u2514\u2500\u2500 logging_manager.cpython-312.pyc\n\u2502       \u2514\u2500\u2500 logging_manager.py\n\u251c\u2500\u2500 test\n\u2502   \u251c\u2500\u2500 chunker\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 test_chunk_manager.py\n\u2502   \u251c\u2500\u2500 reader\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 test_read_manager.py\n\u2502   \u251c\u2500\u2500 splitter\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 splitters\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py\n\u2502   \u2502       \u251c\u2500\u2500 test_fixed_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 test_paragraph_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 test_recursive_splitter.py\n\u2502   \u2502       \u251c\u2500\u2500 test_sentence_splitter.py\n\u2502   \u2502       \u2514\u2500\u2500 test_word_splitter.py\n\u2502   \u2514\u2500\u2500 utils\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 uv.lock\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p>If you like to contribute to my project, please, send an e-mail to andresherencia2000@gmail.com</p>"},{"location":"chunker/docs/","title":"Chunking Documentation","text":"<p>Below is the documentation for the <code>ChunkManager</code> class.</p>"},{"location":"chunker/docs/#src.chunker.chunk_manager.ChunkManager","title":"<code>ChunkManager</code>","text":"<p>Manages the process of saving text chunks into markdown files.</p> <p>This class handles the organization and saving of text chunks generated by the splitting process. It organizes the chunks into a uniquely named folder and writes each chunk to a separate markdown      file.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>A dictionary containing configuration settings.</p> <code>output_path</code> <code>str</code> <p>The directory path where the chunk files will be saved.</p> <code>split_manager</code> <code>SplitManager</code> <p>An instance of SplitManager configured with the provided settings.</p>"},{"location":"chunker/docs/#src.chunker.chunk_manager.ChunkManager.__init__","title":"<code>__init__(config=None, *, input_path=None, output_path=None, split_method=None)</code>","text":"<p>Initializes the ChunkManager with a configuration dictionary or with provided arguments.</p> <p>If no configuration dictionary is provided, it builds one using the provided arguments. The output_path defaults to \"/output\" if not explicitly provided. <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[dict]</code> <p>A dictionary containing configuration settings.</p> <code>None</code> <code>input_path</code> <code>Optional[str]</code> <p>The directory path where input files are stored.</p> <code>None</code> <code>output_path</code> <code>Optional[str]</code> <p>The directory path where the chunk files will be saved.</p> <code>None</code> <code>split_method</code> <code>Optional[str]</code> <p>The method used for splitting the text.</p> <code>None</code>"},{"location":"chunker/docs/#src.chunker.chunk_manager.ChunkManager.save_chunks","title":"<code>save_chunks(chunks, base_filename, original_extension, splitter_method)</code>","text":"<p>Saves the given text chunks into markdown files in a uniquely named directory.</p> <p>The directory is created based on the base filename, original file extension, current date and time, and the splitter method used. Each chunk is saved in a separate markdown file following the naming convention: <code>{base_filename}_{original_extension}_{date}_{time}_chunk_{i}.md</code>.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>List[str]</code> <p>A list of text chunks to be saved.</p> required <code>base_filename</code> <code>str</code> <p>The base name of the original file used to construct output filenames.</p> required <code>original_extension</code> <code>str</code> <p>The file extension of the original file (e.g., \".md\").</p> required <code>splitter_method</code> <code>str</code> <p>The method used for splitting the text (e.g., \"fixed\").</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of file paths where the chunks have been saved.</p>"},{"location":"reader/docs/","title":"Reading Documentation","text":"<p>Below is the documentation for the <code>ReadManager</code> class.</p>"},{"location":"reader/docs/#src.reader.read_manager.ReadManager","title":"<code>ReadManager</code>","text":"<p>Manages the process of reading files from a specified input directory and converting them into Markdown format.</p> <p>This class is responsible for: - Configuring logging based on the provided configuration. - Reading files from a configured input directory. - Converting files (TXT, MD, DOCX, PDF) into Markdown format.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Dict[str, Any]</code> <p>A dictionary containing configuration settings.</p> <code>input_path</code> <code>str</code> <p>The directory path where input files are stored.</p> <code>md</code> <code>Any</code> <p>The Markdown converter instance used for file conversion.</p>"},{"location":"reader/docs/#src.reader.read_manager.ReadManager.__init__","title":"<code>__init__(config=None, *, input_path=None, markdown_converter=None)</code>","text":"<p>Initializes the ReadManager with a configuration dictionary or with provided arguments.</p> <p>If no configuration dictionary is provided, it builds one using the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[Dict[str, Any]]</code> <p>A dictionary containing configuration settings.</p> <code>None</code> <code>input_path</code> <code>Optional[str]</code> <p>The directory path where input files are stored.</p> <code>None</code> <code>markdown_converter</code> <code>Any</code> <p>An instance of a Markdown converter.                                 Defaults to <code>MarkItDown</code>.</p> <code>None</code>"},{"location":"reader/docs/#src.reader.read_manager.ReadManager.read_file","title":"<code>read_file(file_name)</code>","text":"<p>Reads and converts a file to Markdown format.</p> <p>The file is retrieved from the configured input directory. Only files with extensions <code>.txt</code>, <code>.md</code>, <code>.docx</code>, and <code>.pdf</code> are supported. The converted text is returned as a Markdown string.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to be read and converted.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Markdown text content of the converted file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If the file is empty or has an unsupported extension.</p> <code>RuntimeError</code> <p>If an error occurs during file conversion.</p>"},{"location":"splitter/docs/","title":"Splitting Documentation","text":"<p>Below is the documentation for the <code>SplitManager</code> class.</p>"},{"location":"splitter/docs/#src.splitter.split_manager.SplitManager","title":"<code>SplitManager</code>","text":"<p>Manages the process of splitting text into smaller chunks using a configurable splitter.</p> <p>This class utilizes a factory design pattern to instantiate the appropriate splitter based on the provided configuration. It then delegates the splitting of input text to the selected splitter.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>dict</code> <p>A dictionary containing configuration settings.</p> <code>splitter</code> <code>BaseSplitter</code> <p>An instance of the selected splitter.</p>"},{"location":"splitter/docs/#src.splitter.split_manager.SplitManager.__init__","title":"<code>__init__(config=None, *, split_method=None)</code>","text":"<p>Initializes the SplitManager with a configuration dictionary or with provided arguments.</p> <p>If no configuration is provided, a configuration dictionary is built using the provided <code>split_method</code>. Defaults to <code>\"auto\"</code> if not specified.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[dict]</code> <p>A dictionary containing configuration settings.</p> <code>None</code> <code>split_method</code> <code>Optional[str]</code> <p>The method used for splitting the text.</p> <code>None</code>"},{"location":"splitter/docs/#src.splitter.split_manager.SplitManager._create_splitter","title":"<code>_create_splitter()</code>","text":"<p>Factory method to instantiate the desired splitter from configuration.</p> <p>This method loads all parameters for the selected splitting method from the configuration and instantiates the corresponding splitter class.</p> <p>Returns:</p> Name Type Description <code>BaseSplitter</code> <code>BaseSplitter</code> <p>An instance of a class that implements the splitter interface.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified splitting method is not supported.</p>"},{"location":"splitter/docs/#src.splitter.split_manager.SplitManager.split_text","title":"<code>split_text(text)</code>","text":"<p>Splits the provided text into smaller chunks using the configured splitter.</p> <p>If the text is empty or only contains whitespace, a warning is logged and an empty list is returned. In case of an error during splitting, an error is logged and an empty list is returned.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to be split.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of text chunks generated by the splitter.</p>"},{"location":"splitter/docs/#base-splitter","title":"Base Splitter","text":""},{"location":"splitter/docs/#src.splitter.base_splitter.BaseSplitter","title":"<code>BaseSplitter</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"splitter/docs/#src.splitter.base_splitter.BaseSplitter.split","title":"<code>split(text)</code>  <code>abstractmethod</code>","text":"<p>Split the provided text into chunks.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to split.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of text chunks.</p>"},{"location":"splitter/docs/#splitting-methods","title":"Splitting Methods","text":""}]}